# Shopping Cart
本案例展示如何使用Phoenix构建简单的购物车。它包含两个领域，一个是管理购物车的购物车服务，另一个用于管理库存的库存服务。两个领域的代码实现在一个工程内，当然代码之前通过Phoenix调用不会存在直接调用关系，如果需要可以很容易对每个服务独立部署。

**购物车服务**是有状态，管理购物车本身的状态。对状态实现添加和删除商品的功能。在查看购物车时，需要获取到商品的剩余数量是否可以购买（涉及从库存服务中中获取商品余量)

**库存**服务管理商品库存的余量，实现入库和出库的操作。


## 运行启动

`cd shopping-cart`

`mvn spring-boot:run`

启动后,参考下述接口介绍体验功能

## 购物车服务

业务场景中，可以对购物车增加或删除商品，可以识别到商品是一个`实体`，而购物车是一个`聚合根`。购物车是属于用户的，所以购物车的属性包含用户ID。

### 领域对象分析

|对象类型|对象名|类名|状态|职责|
|---|---|---|---|---|
|聚合根|购物车|ShoppingCartAggregate|所属用户、包含商品和数量|增加、删除商品|
|实体|商品|Item|商品ID、名称|只存在添加获取删除商品ID、名称，不修改|


### 接口说明

#### PUT /shoppingcart/{userId}/{itemId}/{qty}

**说明**: 调整购物车的商品数量

- qty > 0: 对某个商品在某个用户购物车中增加qty

- qty < 0: 对某个商品在某个用户购物车中减少qty

**响应**:
```json
购物车调整成功
```
#### GET /shoppingcart/{userId}

**说明**: 获取某个用户的购物车的商品列表(需要判定是否可以购买)。

**响应**:
```json
{"userId":"u001","itemRspList":[{"itemId":"i001","qty":10,"buy":false},{"itemId":"i002","qty":100,"buy":true}]}
```

## 库存服务

业务场景中，库存服务可以对某个商品的库存进行加减，这里商品的状态可以只是ID，也可以包含商品的详细信息，这取决于库存服务是否提供本身的商品信息管理功能。

### 领域对象分析
|对象类型|对象名|类名|状态|职责|
|---|---|---|---|---|
|聚合根|库存|InventoryAggregate|商品ID，商品库存|出库入库某个商品数量|


### 接口说明

#### PUT /inventory/{itemId}/{allocateQty}

**说明**: 对某个商品进行出库或入库操作

- allocateQty > 0: 对某个商品库存增加allocateQty

- allocateQty < 0: 对某个商品库存减少allocateQty

**响应**:
```json
库存调整成功: 库存余额:0, 调整数量：100
```


#### GET /inventory/{itemId}
**说明**: 查看某个商品的库存数量

**响应**:
```json
{"itemId":"i002","balanceQty":100}
```
